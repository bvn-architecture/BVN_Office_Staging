"""
This script takes the relevant svg code from the file generated by illustrator
and places it inside the index.html file.
"""
import requests


def extractCode(filePath, groupNames):
    """
    Extract the relevant svg code from the file generated by illustrator,
    returning it as a list of lines.

    filePath should be the path needed to get to the file as a string
    (e.g. "masterfloorplan.svg"). GroupNames should be the ids of every
    important tag as a list of strings
    (e.g. ["clippaths", "Zones", "Background"]).
    """
    # Initialising list of lines to be returned
    relevantCode = []

    # Copying is true when inside an important group
    # (styleCopy is true when copying the style)
    copying = False
    styleCopy = False

    # List of opening group tags that want to be copied
    groupTags = []
    for name in groupNames:
        groupTags.append('<g id="' + name + '">') 

    # Loop through each line of the svg file.
    with open(filePath) as infile:
        for line in infile:
            if not copying:
                # Check for line being an important group's opening
                if line.strip() in groupTags:
                    copying = True
                    innerGroupCount = 0
                    relevantCode.append(line)

                # Check for opening of style                
                elif line.strip() == '<style type="text/css">':
                    copying = True
                    styleCopy = True
                    relevantCode.append(line)

            else:
                # Check for if copying the style
                if styleCopy:
                    if line.strip() == "</style>":
                        styleCopy = False
                        copying = False

                # Check for inner group opening
                elif line.strip()[:2] == "<g":
                    innerGroupCount += 1
                    # line = line.lower()
                
                # Check for closing of group tag
                elif line.strip()[:3] == "</g":
                    # Check for the actual group closing
                    if innerGroupCount == 0:
                        copying = False
                    else:
                        innerGroupCount -= 1
                
                # Read line in
                relevantCode.append(line)

    cleanerCode = []
    for line in relevantCode:
        # Note: Each backslash has to be written twice to represent one 
        # backslash, i.e. print "\\" => \
        # removalText = "\\\\syd-file\\practice\\Baptiste\\BVN_Office_Staging\\"

        # Removes the class that makes all of one layer invisible
        if line.strip() != ".st0{display:none;}":

            # Removing the context that's present in some paths to linked images
            cleanerCode.append(removeText(line, "\\\\syd-file\\practice\\Baptiste\\BVN_Office_Staging\\"))

    return cleanerCode


def removeText(text, subtextToRemove):
    """
    Clean up a string by removing a substring if it is found
    """
    # Character to search for
    firstChar = subtextToRemove[0]

    # Initialising list of start positions of the text that needs to be removed
    subtextStarts = []
    # Looping through each character
    for charPosition in range(len(text)):
        # Testing against char
        if text[charPosition] == firstChar:
            # Try is necessary as it's possible it will be searching for a larger subtext than exists
            try:
                # Testing for subtext's presence
                if text[charPosition:charPosition+len(subtextToRemove)] == subtextToRemove:
                    subtextStarts.append(charPosition)
            except IndexError:
                # Do nothing
                # print("An IndexError occured, don't worry about it.")
                pass # This line keeps python happy, it doesn't like code blocks with only comments
            except Exception as e:
                print(e)

    # Removing the subtext(s)
    count = 0
    while count < len(subtextStarts):
        # Removing the text
        text = text[:subtextStarts[count]] + text[subtextStarts[count]+len(subtextToRemove):]
        # Incrementing the count
        count += 1

        # Moving each position down relative to the reduction of text
        subtextStarts = [x-len(subtextToRemove) for x in subtextStarts]

    return text


def insertCode(filePath, newSVG):
    """
    Insert the SVG code into the html file.

    filePath should be the path needed to get to the file as a string (e.g. "index.html").
    newSVG should be the code extracted by extractCode() and should be a list of strings (each correlating to one line).

    Does not return anything (the file is updated).
    """
    # This is the line that starts the svg off in the html file.
    svgStartMarker = '<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 1380 1080">'
    
    # Initialising list of lines
    htmlCode = []

    # Initialising pasting variable (True when putting the code in)
    pasting = False

    with open(filePath) as infile:
        for line in infile:
            if pasting:
                if line.strip() == "</svg>":
                    # Stopping the pasting
                    pasting = False

                    # Placing the svg code inside the html code
                    htmlCode.extend(newSVG)

                    # Closing the svg element
                    htmlCode.append(line)
                
                # Note: It does nothing when the line isn't "</svg>".
                # This is effectively just deleting the old svg code.
            
            else:
                # First checking for whether it should start pasting
                if line.strip() == svgStartMarker:
                    pasting = True
                
                # When not pasting, it's copying.
                htmlCode.append(line)
    
    # Initialising output file
    outputFile = open(filePath, 'w')

    # Rewrite the file with the updated SVG
    for line in htmlCode:
        outputFile.write(line)


def runSVGPrep():
    """
    Run the other functions & ask for appropriate user input to prep the files.
    """
    # Extracting the new SVG
    inFile = input("What's the name of svg file generated by illustrator? ")
    newSVG = extractCode(inFile, ["clippaths", "Zones", "Background"])

    # Writing the updated html
    outFile = input("What's the name of html file that needs to be updated? ")
    insertCode(outFile, newSVG)

    # Finished!
    end = input("Press enter to exit.")


# runSVGPrep()








def findDefaults():
    """
    Retreive the default values from defaultValues.csv
    """
    # Opening the file
    layerFile = open("defaultValues.csv", "r")

    # Initialising list
    defaultValues = []

    # There should only be one line
    for line in layerFile:
        # Creating a list of the items
        defaultValues.append(str(line).split(","))

    layerFile.close()

    return defaultValues


def saveDefaults(values):
    """
    Rewrite the default values contained within defaultValues.csv

    "values" should be a list with the items in it:
      - First item: List with one item that's a string (e.g. ["MasterFloorplan.ai"])
      - Second item: List with one item that's a string (e.g. ["index.html"])
      - Third item: List with any number of items that are all strings (e.g. ["clippaths", "Zones", "Background"])
    """
    # Initialising output file
    defaultsFile = open("defaultValues.csv", 'w')

    # Rewrite the file with the updated SVG
    for line in values:
        # Initialising the string for the current line
        lineString = ""

        # Adding each item to string
        for item in line:
            lineString += str(item) + ","

        # Writing the line to the file ([:-1] removes the last comma, "\n" is to end the line)
        defaultsFile.write(lineString[:-1] + "\n")
    
    # Closing the file (this function doesn't return anything)
    defaultsFile.close()


def findFile(question, fileType):
    """
    Ask for file name from user, ensuring that it is valid. Return the file name.
    """
    fileName = input(question)
    
    # Adding the file type ending (e.g. ".svg") if it isn't present
    if fileName[-(len(str(fileType))+1):].lower() != "." + str(fileType).lower():
        fileName += "." + str(fileType)

    try:
        # Trying to open file. If successful, return the file name!
        tempFile = open(fileName, "r")
        tempFile.close()
        return fileName

    except IOError:
        print(str(fileName) + " couldn't be found. Maybe you're one letter off?")

        # Recursive search for file if unfound
        return findFile(question, fileType)


def extractSheetsURL(htmlFileName):
    """
    Extract (and construct) the URL of the google sheets json output
    """

    javascriptVariableName = "window.BVNofficeProgressPublicSpreadsheetUrlKey"

    with open(htmlFileName) as htmlFile:
        for line in htmlFile:
            # Finding the appropriate variable
            if line.strip()[:len(javascriptVariableName)] == javascriptVariableName:
                # Split by apostrophes to get the variable name
                sheetsKey = line.split("'")[1]
                break
    
    return "https://spreadsheets.google.com/feeds/list/" + sheetsKey + "/od6/public/values?alt=json"



def downloadSheetData(googleSheetsURL):
    """
    Download the google sheets data.

    Despite this being quite a small function, it will take a (relatively) large amount of time
    """

    # Downloading the page
    from requests import get
    page = get(googleSheetsURL)

    # Returning the page's content
    return page.content


def formatData(jsonData):
    """
    Extrapolate the appropriate sub-dataset from the google sheets data, saving it to sheetsData.js

    (Now with the json library - hopefully a lot easier)
    """
    import json
    data = json.loads(jsonData)
    
    usefulData = data["feed"]["entry"]

    cellPrefix = "gsx$"

    # Cleaning data (removing unnecessary entries + renaming keys)
    cleanData = []
    for dateEntry in usefulData:
        zoneDict = {}
        # zoneEntry is the key, innerDict is the value
        for zoneEntry, innerDict in dateEntry.iteritems():
            # Only adding values with the "gsx$" prefix
            if zoneEntry[:len(cellPrefix)] == cellPrefix:
                # Chopping off "gsx$", removing unnecessary extra dictionary layer
                zoneDict[zoneEntry[len(cellPrefix):]] = innerDict["$t"]
            
        cleanData.append(zoneDict)
    
    # Writing the data to googleSheetsData.js
    googleSheetsFile = open("googleSheetsData.js", 'w')
    googleSheetsFile.write("window.officeStates = " + removeUnicodeUs(str(cleanData)))
    googleSheetsFile.close()


def removeUnicodeUs(givenString):
    """
    A probably not so great way of removing the annoying "u"s created by the unicode encoding
    """
    previousCharacters = '????'
    cleanString = ""

    for char in givenString:
        previousCharacters = previousCharacters[1:] + char
        if previousCharacters in [": u'", ", u'", ': u"', ', u"'] or previousCharacters[1:] in ["{u'", '{u"']:
            cleanString = cleanString[:-1]
        
        cleanString += char
    return cleanString


def formatData_OLD(jsonData):
    """
    Extrapolate the appropriate sub-dataset from the google sheets data, saving it to sheetsData.js

    testStructure = [[{1:2,2:3,3:4}],[{'d':2,'c':3,'b':4}],[["szzdf","szzdf","szzdf","szzdf","szzdf","dafhdgh"],["abfsdf","asdsdfe","abfsdf","asdsdfe","abfsdf","asdsdfe"],[{1:2,3:4},{1:{1:2,3:4},3:"dgdfg"}],[1,2,3,4,5]],[1,2,3,4,5,6,7]]
    """
    import json

    # Initialising output file's variable
    newFileString = ""

    # Finding start of valuable information
    for charIndex in range(len(jsonData)):
        if jsonData[charIndex:charIndex+8] == '"entry":':
            beginningIndex = charIndex+8
            break

    # Finding end of valuable information
    for charIndex in range(len(jsonData)-1, 0, -1):
        if jsonData[charIndex] == ']':
            endIndex = charIndex + 1
            break
    
    # Getting rid of unnecessary beginnings and endings
    usefulData = jsonData[beginningIndex:endIndex].strip()
    cleanData = ""

    # Initialising variable that keeps track of how deep inside the dictionaries it is
    layersDeep = 0

    # Initialising search index to 0 for search for inner disposable strings
    currentSearchIndex = 0
    disposableString = "$gsx"

    # Initialising boolean that controls the deletion of layers above this level
    deletionLevel = 999

    for char in usefulData[1:-1]:
        
        if char == "{":
            layersDeep += 1
        elif char == "}":
            layersDeep -= 1

            # Exiting deletion if leaving the appropriate layer
            
        elif layersDeep == 1 and char == disposableString[currentSearchIndex] and deletionLevel == 999:
            # Searching for disposable string
            currentSearchIndex += 1

            # Testing for entire string being found
            if currentSearchIndex == len(disposableString):
                currentSearchIndex = 0
                deletionLevel = layersDeep

        elif char == "," and layersDeep <= deletionLevel:
            # Testing for item being
            deletionLevel = 999
    

    # Initialising variables for loop
    currentDepth = 0
    currentItem = ""
    currentSearchString = len(disposableString)*"!"
    disposable = True

    for char in usefulData:
        if char == "," and currentDepth <= 1:
            if not disposable:
                cleanData += currentItem
            elif disposable and currentDepth == 0:
                cleanData += "}"
        
        elif char == "{":
            currentDepth += 1
            if not disposable:
                cleanData += currentItem + "{"
        
        elif char == "}":
            pass







#                  ____    
#                 /    \   
#                /  /\  \  
#               /  /| \  \ 
#              /__// \ \__\
#             |__|/   \|__|
#
#  _____   ____    _______ _    _ _____  _____ 
# |  __ \ / __ \  |__   __| |  | |_   _|/ ____|
# | |  | | |  | |    | |  | |__| | | | | (___  
# | |  | | |  | |    | |  |  __  | | |  \___ \ 
# | |__| | |__| |    | |  | |  | |_| |_ ____) |
# |_____/ \____/     |_|  |_|  |_|_____|_____/




def printStructure(fileStructure, startString=""):
    """
    Print the given variable's structure (intended for dictionaries/lists/etc.)
    """

    structureList = []

    if isinstance(fileStructure, dict):
        structureList.append(startString + "DICT")
        for key, value in fileStructure.iteritems():
            structureList.append(printStructure(value, startString + "    "))
    elif isinstance(fileStructure, (list, tuple)):
        if isinstance(fileStructure, list):
            structureList.append(startString + "LIST")
        else:
            structureList.append(startString + "TUPLE")
        for item in fileStructure:
            structureList.append(printStructure(item, startString + "    "))
    else:
        return "ITEM"

    if structureList != []:
        # Necessary initialisations
        previousItem = [] # default assignment
        itemCount = 1
        newStructureList = []
        #print structureList

        for item in structureList:
            if item == previousItem:
                itemCount += 1
            else:
                if itemCount == 1:
                    newStructureList.append(str(previousItem))
                else:
                    if isinstance(previousItem, str):
                        newStructureList.append(previousItem)
                    elif isinstance(previousItem, list):
                        previousItem.append("x" + str(itemCount))
                        newStructureList.extend(previousItem)

                itemCount = 1
                previousItem = item

        return newStructureList


def run():
    """
    Run all the other functions and ask for appropriate user inputs.
    """

    # Retreiving default values, then printing them appropriately
    defaultValues = findDefaults()

    print("Would you like to run the default settings? This means the following will be assumed: ")
    print('SVG Illustrator file = ' + str(defaultValues[0][0])[:-1])
    print('HTML file = ' + str(defaultValues[1][0])[:-1])
    print('Visible layers = ' + str(defaultValues[2])[1:-4] + "'")

    default = input("Run default settings? (Y/N): ")

    # Lists of phrases that correspond to yes & no answers respectively
    yesPhrases = ["YES", "Y", "YE", "TRUE", "YUP", "YEAH", "YEH", "CORRECT", "POSITIVE"]
    noPhrases = ["NO", "N", "FALSE", "NOPE", "NOP", "NAH", "NUP", "NUH", "INCORRECT", "NEGATIVE"]

    # Flag for question being answered
    answered = False

    # Loop to catch answer or repeat if invalid
    while not answered:
        if default.upper() in yesPhrases:
            # Closing loop
            answered = True

            # "[:-1]"s remove the hanging "\n"s from the end of the lines
            svgFileName = defaultValues[0][0][:-1]
            htmlFileName = defaultValues[1][0][:-1]
            visibleLayers = defaultValues[2][:2]
            visibleLayers.append(defaultValues[2][2][:-1])

        elif default.upper() in noPhrases:

            print("No? We'll go through each setting now.")

            # Finding the svg and html file names
            svgFileName = findFile("Please enter the SVG file's name: ", "svg")
            htmlFileName = findFile("Please enter the HTML file's name: ", "html")
            
            # Some necessary initialisations
            visibleLayers = []
            layerCount = 1
            layerName = "initialisationName"

            # Ordinal number dictionary
            ordinalEndings = {1: "st", 2: "nd", 3: "rd"}

            # Layer name list entering loop
            print("The layer names now need to be entered (enter a blank layer name at any time to finish).")
            print("Please enter each layer name - remember case matters!")
            while layerName != "":
                # Asking for layer name
                layerName = input(str(layerCount) + ordinalEndings.get(layerCount, "th") + " layer name: ").strip()
                if layerName != "":
                    visibleLayers.append(layerName)
                    layerCount += 1
                else:
                    # Ending loop if blank layer name entered
                    break

            saveDefaultAnswer = input("Would you like to save these as the default settings for next time? (Y/N)")
            
            # Loop to catch answer or repeat if invalid
            while not answered:
                if saveDefaultAnswer.upper() in yesPhrases:
                    # Closing loop
                    answered = True

                    print("Saving defaults...")
                    saveDefaults([[svgFileName], [htmlFileName], visibleLayers])
                elif saveDefaultAnswer.upper() in noPhrases:
                    # Closing loop
                    answered = True

                    print("Defaults unchanged.")
                else:
                    print('Sorry, I didn\'t quite understand you there. Please enter a "yes" or a "no"')
                    saveDefaultAnswer = input("Would you like to save these as the default settings for next time? (Y/N)")

            # Closing loop just in case (should be already closed)
            answered = True

        else:
            print('Sorry, I didn\'t quite understand you there. Please enter a "yes" or a "no"')
            default = input("Run default settings? (Y/N): ")
    
    # Do stuff
    # Extracting the new SVG
    print("Extracting the SVG... ")
    newSVG = extractCode(svgFileName, visibleLayers)

    # Writing the updated html
    print("Injecting the SVG into the HTML file... ")
    insertCode(htmlFileName, newSVG)

    print("Extracting google sheets URL...")
    googleSheetsURL = extractSheetsURL(htmlFileName)

    print("Downloading google spreadsheet data...")
    googleSheetsData = downloadSheetData(googleSheetsURL)

    print("Formatting and saving data...")
    formatData(googleSheetsData)


# Running the program
run()

# Finishing up message
end = input("Finished! Press enter to exit.")